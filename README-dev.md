# README

This README is for internal use and a reference for any developer. 

**Roadmap**

* [ ] Documentation: tests for resolving (+add below)
* [ ] Indexes: use Int+hashcode for FQN
* [ ] Indexes: create separates indexes for VAL/LET
* [ ] Indexes: use String for Name
* [ ] Index: module files
* [ ] SmartElements: visibility
* [ ] Navigation: add "resolve" to "let/val/type"
* [ ] Navigation: add "line markers" to "type"
* [ ] Add: open
  * let open
  * Stdlib (OCaml 4.07+)
  * open Stdlib
  * open List (`let length = List.length [1; 2; 3] ;;  print_int length ;;`)
* [ ] Add: module
* [ ] Documentation: element under the cursor (Module?)
* [ ] Add: include (inherit another module)
* [ ] Add: exception
* [ ] Add: function parameters

```none
FilenameIndex.getVirtualFilesByName(
  "filename.extension",
  false,
  GlobalSearchScope.projectScope(element.project)
)
```

## Parser

The parser is the most important element as the parsed tree is used as the base of every feature. As the parser is still very unstable, elements are integrated one by one. 

The plugin is based on a [parser generated by grammar kit](https://github.com/JetBrains/Grammar-Kit). The parser rules are, as much as possible, similar to the one [in the official documentation]( https://v2.ocaml.org/manual/lex.html).

* `OCaml.bnf`: the parser rules for ML and MLI (ML by default, uncomment out the two lines for MLI)
* `_OCamlLexer.flex`: to generate the symbols used by the parser

**Roadmap**

* Add some pins for parser recovery
  * [x] A few example pins were added
  * [ ] Add more pins
  * [ ] Verify/test pins
* [x] Currently parser errors are hidden using highlightErrorFilter ‚úçÔ∏è
* [ ] Make it simple to compile both parsers
* [ ] Ensure parser works on 0Caml 4.14 Code
* [ ] Ensure parser works on 0Caml 4.13 Code
* [ ] Ensure parser works on 0Caml 4.12 Code
* [ ] Ensure parser works on 0Caml 4.11 Code
* [ ] Ensure parser works on 0Caml 4.10 Code

üìö Some tests are required for each parser element.

* `exception Undefined = CamlinternalLazy.Undefined`
* `let test = A.B.C xxx`
* `module A (B: C)` in ML
* ...

## Creating A New Project

The following features were implemented in IntelliJ:

* [x] We can create a project (folder name, git, etc.)
* [x] Working in both the new and the old UI
* [x] Can use a template
  * [x] Dune template
    * [ ] error EDT=>Background
  * [x] Makefile template
  * [x] IntelliJ template
* [x] Can set the project SDK
  * [ ] Can add an SDK from an arbitrary path (Removed Code)
  * * [ ] Can create a "SimpleSDK" (non-opam) (Removed Code)

Once created, we can use the project structure to edit the module configuration (SDK, SRC/OUT folders, etc.).

üìö We can also create new modules the same way as for projects.

## Building/Running the project

We can only run dune executables for now:

* [x] Run icon shown next to the executables name
* [x] Verify the configuration
* [x] Build in the module output folder
* [x] Trigger "dune exec" on Run
* [ ] Support "executables"+"names"
* [ ] Use variables (e.g. Project dir, etc.)
* [ ] Autocompletion of the target
* [ ] Limit the values of target (select?)

We would want:

* [coq](https://github.com/coq/coq.git)
* [ ] Build dune libraries
* [ ] Work on the "build" dependency
* [ ] Test if "makefile" works
* [ ] Implement "IntelliJ" Build&Run

There is something important to note. Currently, the "build" itself is not handled at all. When we run "dune exec", it triggers "build" which moves files in the output folder and does nothing. It eventually works because "dune exec" is first compiling files, but when doing so, it is ALSO copying files in the output folder but in another subfolder, which is not optimal at all.

## Creating New Files

Aside from a new action to create a ".ml", a ".mli", or both, there is nothing worth mentioning.

## File Highlight

Files matching `*.ml`/`*.mli` are highlighted and the following are annotated (in short, it means they are not considered as text and can be used with smart features):

* [x] Variables (LET/VAL)
* [x] Functions (LET/VAL)
* [x] Types (TYPE)
* [ ] Every other element ([process here](#supporting-a-new-element))

Similarly to JAVA, you can change highlight colors in settings:

* [X] Color Settings Page For Highlighter
* [x] Add Highlighter Annotator to Color Settings Page

üìö Dune files are highlighted and annotated too. They also have their colors settings page.

* [ ] Only stuff that can be refactored should be an identifier

## Live Templates

A live template is a code sample that is generated when selected in a specified context. For instance, inside a method in JAVA (context), when we write "for" and select the live template "fori" to generate a "for i loop".

For now, we have the following contexts:

* [x] OCaml file (interface or not)
  * [x] This scope exclude comments
* [ ] Refine the scopes...

And a few templates in `liveTemplates/default.xml`.

‚úçÔ∏è There are no live templates for Dune.

üìö Both OCaml and Dune have Braces matching (hover the other).

## Documentation

For annotated elements, you can use `CTRL+Q`/`<hover>` to view their quick documentation. 

* [x] Can resolve the comment above/below an element
* [x] Support normal comments in-between
* [x] Support annotations comments in-between
* [ ] Use the element on the cursor
  * [ ] Ex: hover an module name => module documentation
* [x] Allow one blank line with orphan doc comment below the element to accommodate "Format.fprintf".

For the rendering of the [odoc](https://ocaml.org/manual/4.12/ocamldoc.html)/[+](https://ocaml.github.io/odoc/ocamldoc_differences.html)/[+](https://github.com/ocaml/odoc) documentation:

* [ ] Create a parser/lexer, handle HTML + tags
* [ ] Implement the "render mode" for sources
* [x] Added an annotator for elements between brackets

Additionally, it would be good if we can generate the documentation.

* [ ] Dune "opam project"
* [ ] Dune "dune build && dune build @doc"
* [ ] Open the documentation?

For normal comments:

* [x] Single Line Comments Handler (CTRL+/)
* [x] Multi Lines Comments Handler (CTRL+SHIFT+/)
* [ ] Comments: space not removed after uncommenting ("(* ")

## Spellchecking

Comments, documentation, strings, and identifiers (annotated elements as identifiers) have spellchecking.

## Structure View

The Structure View can be opened with `ALT+7` for OCaml files. It only shows annotated elements.

* [x] Show the name of the element
* [x] Show the type of the element as an ICON
* [x] Show the visibility of the element as an ICON
* [x] Show nested annotated elements
* [ ] Show function arguments?
* [ ] Use stubs in structure view (better when we don't open a file)

The structure view panel itself can have more features:

* [x] Filter: nested variables
* [x] Filter: variables, functions, types
* [x] Sort: name | Manual test
* [ ] Sort: visibility
* [ ] Group: refer to JAVA implementation for inspiration

A few tests were implemented:

* [x] One/Multiple variable
* [x] Redefinitions
* [x] Deconstructions (Let)
* [x] Anonymous (Let)
* [x] And (Let, Type)

üìö Dune also has a working structure view.

* [ ] Test it
* [ ] Do not show empty lists
* [ ] Do not show values (strings, atoms)

## Navigation

**Implementation/Declaration**

We can show line markers to implementation/declaration for the following elements:

* [x] Variables/Functions
* [ ] Types

To work, we are resolving indexed elements matching the qualified name (ex: A.B.name) of the element (ex: name). For indexes to work, we need to define them in fill them with stub elements.

We defined stubs for every annotated element. **WARNING**: the stub tree is parsed based on the rules in the PsiFileStubImpl associated with the kind of file.

* If an element is not parsed
* This is because the method "skipChildProcessingWhenBuildingStubs"
* Returns `true` (don't parse children) by default

We define the following indexes:

* [x] Variables/Functions
* [x] Types

üìö We don't index anonymous elements:

* [x] Variables/Functions
* [x] Types and VAL declarations CANNOT BE ANONYMOUS

‚ö†Ô∏è Reminder: what about elements in a module, etc.

* [ ] Fix qualified path (maybe not required once modules are qualified)

**Resolve**

From a fully qualified path, we can find the declarations for:

* [x] Variables/Functions (LET/VAL)
* [ ] ...

‚úçÔ∏è Dune is referencing files/paths and that's not handled.

## OCaml SDK

While for the end-user, it's not that important:

* [x] Can detect/use WSL SDKs
* [ ] Can detect/use Cygwin SDKs
* [ ] Can detect/use OCaml64 SDKs
* [ ] Can detect/use Linux SDKs
* [ ] Can add a "SimpleSDK" (non-opam) (Removed Code)
* [x] The SDK files are shown nicely in the Library

There is a bug I can't patch, so the user cannot edit anymore the OCaml manual/API URLs.

üìö We suggest the user to set the SDK if not set.

## Smart Elements

Currently, every element is considering itself as public.

* [ ] Fix this, detect MLI, none==PUBLIC, if MLI, inside==PUBLIC
  * [ ] Sort elements in structure view
* [ ] #isFunction: use type inference?

# Special notes

## Deconstructions

A deconstruction is an element whose name is made of multiple names, e.g., such as `let (x,y) = ...`. Such elements are a pain to handle.

They impact:

* [x] Structure View
* [x] Indexes
* [ ] Spellchecking?
* [ ] ...

Currently, only `LET` is known to introduce variables like this.

# Supporting a new element

Adding support for a new element, e.g. making the element "smart" so that you can resolve its references, usages, etc. requires quite a few steps.

* Add a mixin and a stub ; the element is a named owner
  * Create an element if needed to ensure the element name <small>(ex: variable name)</small> is the first element of the class we will edit. Ex: `value_binding` in `value_description ::= VAL value_binding`
  * Refer to `value_binding` to inject the interfaces/classes/mixin/etc.
  * First, edit `OCamlImplUtils#factory`
  * Second, create the stub class such as in `OCamlTypeDefStub`
  * Third, update the mixin such as in `OCamlTypeDefMixin`
  * Generate the parser
* Add a new index (FQN and not)
* Add or connect to the stub to every index
* Is the element anonymous?
* Update the annotator
* Update the color settings page
* Update the structure view
* Update the presentation handler
* Update the structure view filters
* Update spellchecker if you need to
* Update template contexts if you want
* Update navigation
* ...

# Other missing features

A few of the things that are missing:

* [ ] Warning/Error Annotations
* [ ] Surround With
* [ ] Quotes handler
* [ ] Paste processor
* [ ] Smart enter processor
* [ ] Folding
  * Dune variables?
* [ ] Code completion
* [ ] Find usages
* [ ] Go to
* [ ] Smart rename
  * Dune
    * Cannot rename ":xxx"
    * Cannot rename "-xxx"
    * Cannot rename "a/b/c"